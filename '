use std::collections::HashMap;
use std::sync::Arc;
extern crate serde;

//this struct is exposed as a resource, it stores the data that's
//shoved into the dyon console
#[derive(Default)]
pub struct DyonConsole(pub String);

//this stores everything that's needed to run Dyon code.
pub struct DyonState {
    runtime: dyon::Runtime,
    module: std::sync::Arc<dyon::Module>,
    dyon_data: HashMap<u32, DyonData>,
}
impl DyonState {
    pub fn new() -> Self {
        use crate::prelude::*;
        use current::Current;
        use dyon::{Dfn, Lt, Module, Runtime, Type};
        use specs::{Join, World, LazyUpdate};

        let mut module = Module::new();

        //library functions

        //immediately move an entity somewhere
        fn teleport(rt: &mut Runtime) -> Result<(), String> {
            let world = unsafe { Current::<World>::new() };

            //physics stuff
            let physes = world.read_storage::<Phys>();
            let mut ps = world.write_resource::<PhysState>();
            //entity stuff
            let ents = world.entities();
            let ent = ents.entity(rt.current_object::<u32>("entity")?);
            let coords = glm::make_vec3(&rt.pop_vec4::<[f32; 3]>()?);

            let phys = physes
                .get(ent)
                .ok_or("Teleport requested for non-physical entity.")?;

            ps.set_location(phys, &coords);

            Ok(())
        }
        module.add(
            Arc::new("teleport".into()),
            teleport,
            Dfn {
                lts: vec![Lt::Default],
                tys: vec![Type::Vec4],
                ret: Type::Void,
            },
        );

        fn cache_for(rt: &mut Runtime) -> Result<(), String> {
            let world = unsafe { Current::<World>::new() };
        }
        module.add(
            Arc::new("cache_for".into()),
            teleport,
            Dfn {
                lts: vec![Lt::Default],
                tys: vec![Type::F64],
                ret: Type::Object,
            },
        );

        //get an array of things with this scripting id
        fn all_with_id(rt: &mut Runtime) -> Result<(), String> {
            let world = unsafe { Current::<World>::new() };

            let ents = world.entities();
            let scripting_ids = world.read_storage::<ScriptingIds>();

            let search_id = rt.pop::<String>()?;

            rt.push(
                (&ents, &scripting_ids)
                    .join()
                    //find the entities whose list of scripting_ids contain search_id
                    .filter(|(_, ScriptingIds { ids })| ids.contains(&search_id))
                    //dyon only deals with the id # of the entities, not the entity structs.
                    .map(|(ent, _)| ent.id())
                    //okay now vec that thing and ship it off
                    .collect::<Vec<_>>(),
            );

            Ok(())
        }
        module.add(
            Arc::new("all_with_id".into()),
            all_with_id,
            Dfn {
                lts: vec![Lt::Default],
                tys: vec![Type::Text],
                ret: Type::Array(Box::new(Type::F64)),
            },
        );

        //uses the assemblager to spawn an entity right next to another one.
        fn spawn_at_entity(rt: &mut Runtime) -> Result<(), String> {
            let world = unsafe { Current::<World>::new() };

            //resources
            let ps = world.read_resource::<PhysState>();
            let assemblager = world.read_resource::<Assemblager>();
            let lu = world.read_resource::<LazyUpdate>();
            let ents = world.entities();

            //storages
            let physes = world.read_storage::<Phys>();

            //okay now get the entity, their position, and what to spawn
            let what_to_spawn = &rt.pop::<String>()?;
            let ent = ents.entity(rt.pop::<u32>()?);
            let pos = physes
                .get(ent)
                .and_then(|phys| ps.location(phys))
                .ok_or("can't spawn at an entity which has no position")?;

            assemblager.build_at(what_to_spawn, &lu, &ents, *pos);
            Ok(())
        }
        module.add(
            Arc::new("spawn_at_entity".into()),
            spawn_at_entity,
            Dfn {
                lts: vec![Lt::Default, Lt::Default],
                tys: vec![Type::F64, Type::Text],
                ret: Type::Void,
            },
        );

        //set health of an entity
        fn set_hp(rt: &mut Runtime) -> Result<(), String> {
            let world = unsafe { Current::<World>::new() };

            let ents = world.entities();
            let ent = ents.entity(rt.current_object::<u32>("entity")?);
            let mut health_storage = world.write_storage::<Health>();
            let mut health = health_storage
                .get_mut(ent)
                .ok_or("Entity does not have health component")?;
            let health_value = rt.pop::<f32>()?;
            health.value = health.max.min(health_value);

            Ok(())
        }
        module.add(
            Arc::new("set_hp".into()),
            set_hp,
            Dfn {
                lts: vec![Lt::Default],
                tys: vec![Type::F64],
                ret: Type::Void,
            },
        );

        //set health to a certain % of the current health
        fn set_hp_percent(rt: &mut Runtime) -> Result<(), String> {
            let world = unsafe { Current::<World>::new() };

            let ents = world.entities();
            let ent = ents.entity(rt.current_object::<u32>("entity")?);
            let mut health_storage = world.write_storage::<Health>();
            let mut health = health_storage
                .get_mut(ent)
                .ok_or("Entity does not have health component")?;
            let percent = rt.pop::<f32>()?;
            health.value = health.max.min((percent / 100.0) * health.max);

            Ok(())
        }
        module.add(
            Arc::new("set_hp_percent".into()),
            set_hp_percent,
            Dfn {
                lts: vec![Lt::Default],
                tys: vec![Type::F64],
                ret: Type::Void,
            },
        );

        //change health of an entity
        fn change_hp(rt: &mut Runtime) -> Result<(), String> {
            let world = unsafe { Current::<World>::new() };

            let ents = world.entities();
            let ent = ents.entity(rt.current_object::<u32>("entity")?);
            let mut health_storage = world.write_storage::<Health>();
            let mut health = health_storage
                .get_mut(ent)
                .ok_or("Entity does not have health component")?;
            let health_value = rt.pop::<f32>()?;
            health.value += health.max.min(health.value + health_value);

            Ok(())
        }
        module.add(
            Arc::new("change_hp".into()),
            change_hp,
            Dfn {
                lts: vec![Lt::Default],
                tys: vec![Type::F64],
                ret: Type::Void,
            },
        );

        //change health by a certain % of the current health
        fn change_hp_percent(rt: &mut Runtime) -> Result<(), String> {
            let world = unsafe { Current::<World>::new() };

            let ents = world.entities();
            let ent = ents.entity(rt.current_object::<u32>("entity")?);
            let mut health_storage = world.write_storage::<Health>();
            let mut health = health_storage
                .get_mut(ent)
                .ok_or("Entity does not have health component")?;
            let percent = rt.pop::<f32>()?;
            health.value += health.max.min((percent / 100.0) * health.value);

            Ok(())
        }
        module.add(
            Arc::new("change_hp_percent".into()),
            change_hp_percent,
            Dfn {
                lts: vec![Lt::Default],
                tys: vec![Type::F64],
                ret: Type::Void,
            },
        );

        //log a message into the Dyon console in the DevUi
        fn log(rt: &mut Runtime) -> Result<(), String> {
            let world = unsafe { Current::<World>::new() };
            let mut dyon_console = world.write_resource::<DyonConsole>();

            //get the message they passed as an argument to the function
            let message: Arc<String> = rt.pop()?;
            dyon_console.0.push_str(&format!("{}\n", &**message));
            Ok(())
        }
        module.add(
            Arc::new("log".into()),
            log,
            Dfn {
                lts: vec![Lt::Default],
                tys: vec![Type::Text],
                ret: Type::Void,
            },
        );

        //finally, return the instance with the filled module and runtime.
        Self {
            runtime: Runtime::new(),
            module: Arc::new(module),
            dyon_data: DyonData::default(),
        }
    }

    pub fn run(&mut self) {
        use crate::prelude::*;
        use current::Current;
        use dyon::{load, Call};
        use specs::Join;

        //I'm fairly sure this world has to be dropped
        let script_events = {
            let world = unsafe { &*Current::<specs::World>::new() };
            let entities = world.entities();
            let mut event_storage = world.write_storage::<ScriptEvent>();
            (event_storage.drain(), &entities)
                .join()
                //we only want the ids for our purposes,
                .map(|(e, x)| (e, x.id()))
                .collect::<Vec<_>>()
                //copy so no references to the world remain!
                .clone()
        };
        let mut events_iter = script_events.iter().peekable();

        //if there's actually at least one event to bother cloning the module for...
        if events_iter.peek().is_some() {
            //reload the code containing the function they want in case they changed it
            let mut module = (*self.module).clone();
            let module_load_error = load("src/dyon/test.dyon", &mut module)
                .err()
                //these are almost always syntax errors but I guess they could
                //be other things actually? whatever I'll just leave it this way.
                .map(|x| format!(" --- SYNTAX ERROR --- \n{}\n\n", x));
            let module = Arc::new(module);

            //output
            let output = script_events
                .iter()
                //call each script_event's handler, and collect the errors
                .map(|(script_event, id)| {
                    let event_handler = Call::new(&script_event.function).arg(*id);
                    event_handler.run(&mut self.runtime, &Arc::clone(&module))
                })
                //now combine all of the errors into one,
                .fold(
                    //starting with the errors from loading the module,
                    //or an empty string if there were none,
                    module_load_error.unwrap_or(String::new()),
                    //then for each script event that was run,
                    //add its error too if it emitted one.
                    |mut acc, res| {
                        match res {
                            //we only care about the errors
                            Err(err) => {
                                acc.push_str(&format!(" --- ERROR --- \n{}\n\n", err));
                            }
                            _ => {}
                        };
                        acc
                    },
                );

            //quickly add the errors that could've been outputted to the console
            let world = unsafe { &*Current::<specs::World>::new() };
            let mut dyon_console = world.write_resource::<DyonConsole>();
            dyon_console.0.push_str(&output);
        }
    }
}

//this is the fancy little struct that stores all of the data
//for the scripts. It's formatted this way so that the data can 
//also be saved, when that needs to occur.
use serde::ser::{self, Serialize, Serializer, SerializeMap, Error};

#[derive(Default)]
pub struct DyonData {
    pub data: Box<HashMap<Arc<String>, dyon::Variable>>,
}

impl Serialize for DyonData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use dyon::Variable::*;

        let mut map = serializer.serialize_map(Some(self.data.len()))?;

        for (k, v) in self.data.iter() {
            map.serialize_entry(&**k, &(match v {
                Text(dyon_string) => Ok(dyon_string.to_string()),
                F64(dyon_num, _) => Ok(dyon_num.to_string()),
                Bool(dyon_bool, _) => Ok(dyon_bool.to_string()),
                _ => Err(S::Error::custom("The game can't save a variable of that type!")),
            }?))?;
        }

        map.end()
    }
}
